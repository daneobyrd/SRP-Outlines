/*Source: https://github.com/Daniel-A-Gutierrez/URP-Tech-Art-Showcase/tree/master/Assets/wk1_kawase
Kawase compute implementation created in the video "Writing Render Passes Using the scriptable Render Pipeline in Unity"
Here: https://youtu.be/rimx8nnsbRs

His implementation is based on this fantastic Intel article about real-time gpu-based blurring
Here: https://www.intel.com/content/www/us/en/developer/articles/technical/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms.html
*/

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ThresholdStep
#pragma kernel KBlur
// #pragma kernel Add

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Assets/Resources/RenderPass/XRInclude/TextureXR.hlsl"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
TEXTURE2D_X(Source);
RW_TEXTURE2D_X(float4, Result);
TEXTURE2D_X(CameraTex);
RW_TEXTURE2D_X(float4, Final);
float threshold;
float intensity;
float skip;
int width;
int height;

SamplerState sampler_LinearClamp;

[numthreads(8,8,1)]
void ThresholdStep(uint3 id : SV_DispatchThreadID)
{
    //TempSource[id.xy] = float4(1, 1, 0, 1);
    float4 src = SAMPLE_TEXTURE2D_X_LOD(Source, sampler_LinearClamp, float2(id.xy) / float2(width, height), 0);
    //TempSource[id.xy] = step( float4(threshold, threshold, threshold, threshold), src)* src;
    //if a-threshold > 0 use a. so if a>threshold a, else 0
    //not exactly what i want though because it reduces *all* the component colors that dont meet threshold. so instead

    Result[COORD_TEXTURE2D_X(id.xy)] = step(.001f, dot(step(float4(threshold, threshold, threshold, threshold), src), float4(1, 1, 1, 1))) * src;
    // use dot like an OR but for floats
}

[numthreads(8, 8, 1)]
void KBlur(uint3 id : SV_DispatchThreadID)
{
    //Result[id.xy] = float4(0, 1, 1, 1);
    float2 dims = float2(width, height);
    Result[COORD_TEXTURE2D_X(id.xy)] =
    (SAMPLE_TEXTURE2D_X_LOD(Source, sampler_LinearClamp, (float2(id.xy) + float2(-skip, -skip)) / dims, 0)
        + SAMPLE_TEXTURE2D_X_LOD(Source, sampler_LinearClamp, (float2(id.xy) + float2(-skip, skip)) / dims, 0)
        + SAMPLE_TEXTURE2D_X_LOD(Source, sampler_LinearClamp, (float2(id.xy) + float2( skip, skip)) / dims, 0)
        + SAMPLE_TEXTURE2D_X_LOD(Source, sampler_LinearClamp, (float2(id.xy) + float2( skip, -skip)) / dims, 0)) / 4.0f;
}

// [numthreads(8, 8, 1)]
// void Add(uint3 id : SV_DispatchThreadID)
// {
//     //Result[id.xy] = float4(0, 1, 1, 1);
//     float2 dims = float2(width, height);
//     Final[COORD_TEXTURE2D_X(id.xy)] =
//         SAMPLE_TEXTURE2D_X_LOD(Source, sampler_LinearClamp, float2(id.xy) / dims, 0) * intensity
//         + SAMPLE_TEXTURE2D_X_LOD(CameraTex, sampler_LinearClamp, float2(id.xy) / dims, 0);
// }


//kawase : 0,1,2,2,3 at displacements 1.5,2.5,2.5,3.5
//want 2 kernels : one to copy in and downres, one to 
//https://developer.download.nvidia.com/cg/step.html
