#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel KFreiChen                           KERNEL_SIZE=8   MAIN_FREI_CHEN=KFreiChen

#include "Packages/com.unity.render-pipelines.universal/Shaders/PostProcessing/Common.hlsl"
#include "FC_Filters.hlsl"
#include "FC_Approx.hlsl"

TEXTURE2D(Source);
RW_TEXTURE2D(float4, Result);

CBUFFER_START(cbuff)
float4 _Size; // x: src width, y: src height, zw: unused
CBUFFER_END

// 16x16 pixels with an 8x8 center that we will be detecting. Each uint is two color
// channels packed together.
// The reason for separating channels is to reduce bank conflicts in the local data memory
// controller. A large stride will cause more threads to collide on the same memory bank.
groupshared uint gs_cacheR[128];
groupshared uint gs_cacheG[128];
groupshared uint gs_cacheB[128];
groupshared uint gs_cacheA[128];

static const int2 sample_offsets[9] =
{
    int2(-1, 1), int2(0, 1), int2(1, 1),
    int2(-1, 0), int2(0, 0), int2(1, 0),
    int2(-1, -1), int2(0, -1), int2(1, -1)
};

void ApplyFreiChen(float4 input[9], float3x3 cnvMask, out float4 cnv_result)
{
    float3x3 r_f3x3 =
    {
        input[0].r, input[1].r, input[2].r,
        input[3].r, input[4].r, input[5].r,
        input[6].r, input[7].r, input[8].r
    };

    float3x3 g_f3x3 =
    {
        input[0].g, input[1].g, input[2].g,
        input[3].g, input[4].g, input[5].g,
        input[6].g, input[7].g, input[8].g
    };

    float3x3 b_f3x3 =
    {
        input[0].b, input[1].b, input[2].b,
        input[3].b, input[4].b, input[5].b,
        input[6].b, input[7].b, input[8].b
    };

    float3x3 a_f3x3 =
    {
        input[0].a, input[1].a, input[2].a,
        input[3].a, input[4].a, input[5].a,
        input[6].a, input[7].a, input[8].a
    };
    // Dot product is perfect for convolution
    // A = (a1, a2, a3 ... aN);
    // B = (b1, b2, b3 ... bN);
    // A•B = (a1b1 + a2b2 + a3b3 + ... aNbN);
    
    // Red Channel
    const float dot3_r = dot(cnvMask[0], r_f3x3[0])
                         + dot(cnvMask[1], r_f3x3[1])
                         + dot(cnvMask[2], r_f3x3[2]);
    float dp3_r = dot3_r * dot3_r;

    // Green Channel
    const float dot3_g = dot(cnvMask[0], g_f3x3[0])
                         + dot(cnvMask[1], g_f3x3[1])
                         + dot(cnvMask[2], g_f3x3[2]);
    float dp3_g = dot3_g * dot3_g;

    // Blue Channel
    const float dot3_b = dot(cnvMask[0], b_f3x3[0])
                         + dot(cnvMask[1], b_f3x3[1])
                         + dot(cnvMask[2], b_f3x3[2]);
    float dp3_b = dot3_b * dot3_b;

    // Alpha Channel
    const float dot3_a = dot(cnvMask[0], a_f3x3[0])
                         + dot(cnvMask[1], a_f3x3[1])
                         + dot(cnvMask[2], a_f3x3[2]);
    float dp3_a = dot3_a * dot3_a;


    cnv_result = float4(dp3_r, dp3_g, dp3_b, dp3_a);
}

float4 ApproxFreiChen(float4 sqInput[9], float3x3 cnvMask)
{
    float3x3 r_f3x3 =
    {
        sqInput[0].r, sqInput[1].r, sqInput[2].r,
        sqInput[3].r, sqInput[4].r, sqInput[5].r,
        sqInput[6].r, sqInput[7].r, sqInput[8].r
    };

    float3x3 g_f3x3 =
    {
        sqInput[0].g, sqInput[1].g, sqInput[2].g,
        sqInput[3].g, sqInput[4].g, sqInput[5].g,
        sqInput[6].g, sqInput[7].g, sqInput[8].g
    };

    float3x3 b_f3x3 =
    {
        sqInput[0].b, sqInput[1].b, sqInput[2].b,
        sqInput[3].b, sqInput[4].b, sqInput[5].b,
        sqInput[6].b, sqInput[7].b, sqInput[8].b
    };

    float3x3 a_f3x3 =
    {
        sqInput[0].a, sqInput[1].a, sqInput[2].a,
        sqInput[3].a, sqInput[4].a, sqInput[5].a,
        sqInput[6].a, sqInput[7].a, sqInput[8].a
    };
    
    // Dot product is perfect for convolution
    // A = (a1, a2, a3 ... aN);
    // B = (b1, b2, b3 ... bN);
    // A•B = (a1b1 + a2b2 + a3b3 + ... aNbN);
    
    // Red Channel
    const float dot3_r = dot(cnvMask[0], r_f3x3[0])
                         + dot(cnvMask[1], r_f3x3[1])
                         + dot(cnvMask[2], r_f3x3[2]);
    float dp3_r = dot3_r * dot3_r;

    // Green Channel
    const float dot3_g = dot(cnvMask[0], g_f3x3[0])
                         + dot(cnvMask[1], g_f3x3[1])
                         + dot(cnvMask[2], g_f3x3[2]);
    float dp3_g = dot3_g * dot3_g;

    // Blue Channel
    const float dot3_b = dot(cnvMask[0], b_f3x3[0])
                         + dot(cnvMask[1], b_f3x3[1])
                         + dot(cnvMask[2], b_f3x3[2]);
    float dp3_b = dot3_b * dot3_b;

    // Alpha Channel
    const float dot3_a = dot(cnvMask[0], a_f3x3[0])
                         + dot(cnvMask[1], a_f3x3[1])
                         + dot(cnvMask[2], a_f3x3[2]);
    float dp3_a = dot3_a * dot3_a;


    return float4(dp3_r, dp3_g, dp3_b, dp3_a);
}


[numthreads(KERNEL_SIZE, KERNEL_SIZE, 1)]
void MAIN_FREI_CHEN(uint2 groupId : SV_GroupID,                   // ID of thread group; range depends on Dispatch call.
                    uint2 groupThreadId : SV_GroupThreadID,       // ID of thread in a thread group; range depends on numthreads.
                    uint3 dispatchThreadId : SV_DispatchThreadID) // = SV_GroupID * numthreads + SV_GroupThreadID.
{
    // if (SAMPLE_TEXTURE2D_LOD(Source, sampler_LinearClamp, dispatchThreadId.xy, 0).r == 0.0)
    if (Source.Load(dispatchThreadId).r == 0.0)
    {
        Result[dispatchThreadId.xy] = 0;
    }
    else
    {
        
        float2 texelSize = float2(1.0 / _Size.xy);
        float2 uv = float2(float2(dispatchThreadId.xy) * texelSize);

        static float3x3 G[9] =
        {
            G0, G1, G2,
            G3, G4, G5,
            G6, G7, G8
        };

        static float r_intensity[9];
        static float g_intensity[9];
        static float b_intensity[9];
        static float a_intensity[9];
        static float4 intensity[9];
        static float4 sq_i[9];


        static float4 cnv[9];
        // static float4 approx_cnv[5];
        // static float4 sq_cnv[2];

        UNITY_UNROLL
        for (int k = 0; k < 9; ++k)
        {
            float4 pixel_sample = Source[uint2(dispatchThreadId.xy + sample_offsets[k])];
            // float4 pixel_sample = SAMPLE_TEXTURE2D_LOD(Source, sampler_PointClamp, float2(uint2(dispatchThreadId.xy + sample_offsets[k]) * texelSize),                                                   0);
            r_intensity[k] = length(pixel_sample.x);
            g_intensity[k] = length(pixel_sample.y);
            b_intensity[k] = length(pixel_sample.z);
            a_intensity[k] = length(pixel_sample.w);

            intensity[k] = float4(r_intensity[k], g_intensity[k], b_intensity[k], a_intensity[k]);
            sq_i[k] = pow(intensity[k], 2);
        }
        
        /* calculate the convolution values for all the masks */
        UNITY_UNROLL
        for (int n = 0; n < 9; n++)
        {
            ApplyFreiChen(intensity, G[n], cnv[n]);
        }

        const float4 M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);
        const float4 S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);
        const float4 sqrt_ms = sqrt(M / S);
        const float4 fc = float4(acos(sqrt_ms));
        

    
        /*    Test approx. by using sum of kernels    */

        ////////////////////////////////////////////
        /* Sum of first four && Sum of last 5 + M */
        ////////////////////////////////////////////
    
        /*
        m_ = Sum of G0:G3
        s_m = Sum of G4:G8 + m_
        ApplyFreiChen(intensity, m_, approx_cnv[0]);
        ApplyFreiChen(intensity, s_m, approx_cnv[1]);
        const float4 fc = acos(sqrt(approx_cnv[0]/approx_cnv[1]));
        */

        ///////////////////////////////
        /*    Sum of kernel pairs    */
        ///////////////////////////////
    
        /*
        // G0 + G1
        ApplyFreiChen(intensity, G0G1, approx_cnv[0]);
        // G2 + G3
        ApplyFreiChen(intensity, G2G3, approx_cnv[1]);
        // G4 + G5
        ApplyFreiChen(intensity, G4G5, approx_cnv[2]);
        // G6 + G7
        ApplyFreiChen(intensity, G6G7, approx_cnv[3]);
        // G8 + M_
        ApplyFreiChen(intensity, G8M_, approx_cnv[4]);
        
        const float4 M = (approx_cnv[0]) + (approx_cnv[1]);
        const float4 S = (approx_cnv[2]) + (approx_cnv[3]) + (approx_cnv[4]);
    
        const float4 sqrt_ms = sqrt(M / S);
        const float4 fc = float4(acos(sqrt_ms));
        */

        /////////////////////////////////
        /* I² * Sum of squared kernels */
        /////////////////////////////////

        /*
        const float4 m = sq_cnv[0] = ApproxFreiChen(sq_i, sq_G0G3);
        sq_cnv[1] = ApproxFreiChen(sq_i, sq_G4G8);
        const float4 s = m + sq_cnv[1];
        const float4 sqrt_ms = sqrt(sq_cnv[0]/s);
        const float4 fc = acos(sqrt_ms);
        */
    
        Result[dispatchThreadId.xy] = fc;
    }
}
