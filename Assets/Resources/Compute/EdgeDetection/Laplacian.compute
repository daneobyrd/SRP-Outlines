#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel KLaplacian                           GROUP_SIZE=32   MAIN_LAPLACIAN=KLaplacian
#pragma kernel KComposite                           GROUP_SIZE=8   MAIN_COMPOSITE=KComposite
// #define REGION_PER_THREAD 8

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Assets/Resources/RenderPass/XRInclude/TextureXR.hlsl"
#include "LaplacianFilters.hlsl"

CBUFFER_START(cb)
float4 _Size; // x: src width, y: src height, zw: unused
CBUFFER_END

TEXTURE2D_X(Source);
RW_TEXTURE2D_X(float4, Result);
TEXTURE2D_X(CameraTex);

SamplerState sampler_LinearClamp;

uint sample_size = 9;
float laplacian[9];
int2 sample_coords[9] =
{
    int2(-1, 1),  int2(0, 1),  int2(1, 1),
    int2(-1, 0),  int2(0, 0),  int2(1, 0),
    int2(-1, -1), int2(0, -1), int2(1, -1)
};

/*
// 16x16 pixels with an 8x8 center that we will be blurring writing out. Each uint is two color
// channels packed together.
// The reason for separating channels is to reduce bank conflicts in the local data memory
// controller. A large stride will cause more threads to collide on the same memory bank.
groupshared uint gs_cacheR[128];
groupshared uint gs_cacheG[128];
groupshared uint gs_cacheB[128];
groupshared uint gs_cacheA[128];

/*
    ┌────┬────┬────┐    ┌─────┬─────┬─────┐    ┌────┬────┬────┐
    │ 00 │ 01 │ 02 │    │  f0 │  f2 │  f3 │    │ f3 │ f2 │ f3 │
    ├────┼────┼────┤    └─────┴─────┴─────┘    ├────┼────┼────┤
    │ 03 │ 04 │ 05 │      filter[3]            │ f2 │ f0 │ f2 │
    ├────┼────┼────┤      f0 = center          ├────┼────┼────┤
    │ 06 │ 07 │ 08 │      f1 = edge            │ f3 │ f2 │ f3 │
    └────┴────┴────┘      f2 = corner          └────┴────┴────┘
#1#
float4 ApplyLaplacian_3x3(float4 sample_3x3[9])
{
    return laplace_3x3_0[0] * (sample_3x3[4])
         + laplace_3x3_0[1] * (sample_3x3[1] + sample_3x3[3] + sample_3x3[5] + sample_3x3[7])
         + laplace_3x3_0[2] * (sample_3x3[0] + sample_3x3[2] + sample_3x3[6] + sample_3x3[8]);
}

/*
    ┌────┬────┬────┬────┬────┐                              ╔════╗••••••••••••••••••••
    │ 00 │ 01 │ 02 │ 03 │ 04 │    filter[6]:                ║ f5 ║ f4 • f3 • f4 • f5 •
    ├────┼────┼────┼────┼────┤    only need 6 values        ╠════╬════╗•••••••••••••••
    │ 05 │ 06 │ 07 │ 08 │ 09 │    f0 = center               ║ f4 ║ f2 ║ f1 • f2 • f4 •
    ├────┼────┼────┼────┼────┤    f1 = inner edge           ╠════╬════╬════╗••••••••••
    │ 10 │ 11 │ 12 │ 13 │ 14 │    f2 = inner corner         ║ f3 ║ f1 ║ f0 ║ f1 • f3 •
    ├────┼────┼────┼────┼────┤                              ╚════╩════╩════╝••••••••••
    │ 15 │ 16 │ 17 │ 18 │ 19 │    f3 = outer edge           • f4 • f2 • f1 • f2 • f4 •
    ├────┼────┼────┼────┼────┤    f4 = outer edge adjacent  ••••••••••••••••••••••••••
    │ 20 │ 21 │ 22 │ 23 │ 24 │    f5 = outer corner         • f5 • f4 • f3 • f4 • f5 •
    └────┴────┴────┴────┴────┘                              ••••••••••••••••••••••••••
#1#
float4 ApplyLaplacian_5x5(float4 sample_5x5[25])
{

    const float4 center   = laplace_5x5_0[0] * (sample_5x5[12]);
    const float4 edge_0   = laplace_5x5_0[1] * (sample_5x5[7] + sample_5x5[11] + sample_5x5[13] + sample_5x5[17]);
    const float4 corner_0 = laplace_5x5_0[2] * (sample_5x5[6] + sample_5x5[8] + sample_5x5[16] + sample_5x5[18]);
    
    const float4 edge_1a  = laplace_5x5_0[3] * (sample_5x5[2] + sample_5x5[10] + sample_5x5[14] + sample_5x5[22]);
    const float4 edge_1b  = laplace_5x5_0[4] * (sample_5x5[1] + sample_5x5[3] + sample_5x5[05] + sample_5x5[9] + sample_5x5[15] + sample_5x5[19] + sample_5x5[21] + sample_5x5[23]);
    const float4 corner_1 = laplace_5x5_0[5] * (sample_5x5[0] + sample_5x5[4] + sample_5x5[20] + sample_5x5[24]);
    
    return
        center + edge_0 + corner_0
        + edge_1a + edge_1b + corner_1;
}

float4 ApplyLaplacian_7x7(float4 sample_7x7[49])
{
    const float4 center   = laplace_7x7_0[0] * (sample_7x7[25]);
    const float4 edge_0   = laplace_7x7_0[1] * (sample_7x7[18] + sample_7x7[24] + sample_7x7[26] + sample_7x7[32]);
    const float4 corner_0 = laplace_7x7_0[2] * (sample_7x7[17] + sample_7x7[19] + sample_7x7[31] + sample_7x7[33]);
    
    const float4 edge_1a  = laplace_7x7_0[3] * (sample_7x7[10] + sample_7x7[23] + sample_7x7[27] + sample_7x7[38]);
    const float4 edge_1b  = laplace_7x7_0[4] * (sample_7x7[9] + sample_7x7[11] + sample_7x7[15] + sample_7x7[19] + sample_7x7[29] + sample_7x7[33] + sample_7x7[37] + sample_7x7[39]);
    const float4 corner_1 = laplace_7x7_0[5] * (sample_7x7[8] + sample_7x7[12] + sample_7x7[36] + sample_7x7[40]);

    const float4 edge_2a  = laplace_7x7_0[6] + (sample_7x7[3] + sample_7x7[21] + sample_7x7[27] + sample_7x7[45]);
    const float4 edge_2b  = laplace_7x7_0[7] + (sample_7x7[2] + sample_7x7[4] + sample_7x7[14] + sample_7x7[20] + sample_7x7[28] + sample_7x7[34] + sample_7x7[44] + sample_7x7[46]);
    const float4 edge_2c  = laplace_7x7_0[8] + (sample_7x7[1] + sample_7x7[5] + sample_7x7[7] + sample_7x7[13] + sample_7x7[35] + sample_7x7[41] + sample_7x7[43] + sample_7x7[47]);
    const float4 corner_2 = laplace_7x7_0[9] + (sample_7x7[0] + sample_7x7[6] + sample_7x7[42] + sample_7x7[48]);
    
    return
        center + edge_0 + corner_0
        + edge_1a + edge_1b + corner_1
        + edge_2a + edge_2b + edge_2c + corner_2;
}

float4 ApplyLaplacian_9x9(float4 sample_9x9[81]) // outer rim is currently "0" padding
{
    const float4 center   = laplace_9x9_0[0] * (sample_9x9[40]);
    const float4 edge_0   = laplace_9x9_0[1] * (sample_9x9[31] + sample_9x9[39] + sample_9x9[41] + sample_9x9[49]);
    const float4 corner_0 = laplace_9x9_0[2] * (sample_9x9[30] + sample_9x9[32] + sample_9x9[48] + sample_9x9[50]);
    
    const float4 edge_1a  = laplace_9x9_0[3] * (sample_9x9[22] + sample_9x9[38] + sample_9x9[42] + sample_9x9[58]);
    const float4 edge_1b  = laplace_9x9_0[4] * (sample_9x9[21] + sample_9x9[23] + sample_9x9[29] + sample_9x9[33] + sample_9x9[47] + sample_9x9[51] + sample_9x9[57] + sample_9x9[59]);
    const float4 corner_1 = laplace_9x9_0[5] * (sample_9x9[20] + sample_9x9[24] + sample_9x9[56] + sample_9x9[60]);

    const float4 edge_2a  = laplace_9x9_0[6] + (sample_9x9[13] + sample_9x9[37] + sample_9x9[43] + sample_9x9[67]);
    const float4 edge_2b  = laplace_9x9_0[7] + (sample_9x9[12] + sample_9x9[14] + sample_9x9[28] + sample_9x9[34] + sample_9x9[46] + sample_9x9[52] + sample_9x9[66] + sample_9x9[68]);
    const float4 edge_2c  = laplace_9x9_0[8] + (sample_9x9[11] + sample_9x9[15] + sample_9x9[19] + sample_9x9[25] + sample_9x9[55] + sample_9x9[61] + sample_9x9[65] + sample_9x9[69]);
    const float4 corner_2 = laplace_9x9_0[9] + (sample_9x9[10] + sample_9x9[16] + sample_9x9[64] + sample_9x9[70]);

    // const float4 edge_3a  = 0 * (sample_9x9[4] + sample_9x9[36] + sample_9x9[44] + sample_9x9[76]);
    // const float4 edge_3b  = 0 * (sample_9x9[3] + sample_9x9[5] + sample_9x9[27] + sample_9x9[35] + sample_9x9[45] + sample_9x9[53] + sample_9x9[75] + sample_9x9[77]);
    // const float4 edge_3c  = 0 * (sample_9x9[2] + sample_9x9[6] + sample_9x9[18] + sample_9x9[26] + sample_9x9[54] + sample_9x9[62] + sample_9x9[74] + sample_9x9[78]);
    // const float4 edge_3d  = 0 * (sample_9x9[1] + sample_9x9[7] + sample_9x9[9] + sample_9x9[17] + sample_9x9[63] + sample_9x9[71] + sample_9x9[73] + sample_9x9[79]);
    // const float4 corner_3 = 0 * (sample_9x9[0] + sample_9x9[8] + sample_9x9[72] + sample_9x9[80]);

    return
        center + edge_0 + corner_0
        + edge_1a + edge_1b + corner_1
        + edge_2a + edge_2b + edge_2c + corner_2;
        // + edge_3a + edge_3b + edge_3c + edge_3d + corner_3;
}

void Store2Pixels(uint index, float4 pixel1, float4 pixel2)
{
    gs_cacheR[index] = f32tof16(pixel1.r) | f32tof16(pixel2.r) << 16;
    gs_cacheG[index] = f32tof16(pixel1.g) | f32tof16(pixel2.g) << 16;
    gs_cacheB[index] = f32tof16(pixel1.b) | f32tof16(pixel2.b) << 16;
    gs_cacheA[index] = f32tof16(pixel1.a) | f32tof16(pixel2.a) << 16;
}

void Load2Pixels(uint index, out float4 pixel1, out float4 pixel2)
{
    uint rr = gs_cacheR[index];
    uint gg = gs_cacheG[index];
    uint bb = gs_cacheB[index];
    uint aa = gs_cacheA[index];
    pixel1 = float4(f16tof32(rr), f16tof32(gg), f16tof32(bb), f16tof32(aa));
    pixel2 = float4(f16tof32(rr >> 16), f16tof32(gg >> 16), f16tof32(bb >> 16), f16tof32(aa >> 16));
}

/*
void Store1Pixel(uint index, float4 pixel)
{
    gs_cacheR[index] = asuint(pixel.r);
    gs_cacheG[index] = asuint(pixel.g);
    gs_cacheB[index] = asuint(pixel.b);
    gs_cacheA[index] = asuint(pixel.a);
}

void Load1Pixel(uint index, out float4 pixel)
{
    pixel = asfloat(uint4(gs_cacheR[index], gs_cacheG[index], gs_cacheB[index], gs_cacheA[index]));
}
#1#

void DetectEdges(uint2 pixelCoord, uint topLeftMostIndex, uint index)
{
    if (index == 0) { index = 9; }
    float4 s_array[index];
    for (uint i = 0; i < index; i++)
    {
        float4 current, next;
        Load2Pixels(topLeftMostIndex + i, current, next);
        s_array[i] = current;
        s_array[i + 1] = next;
    }

    float4 outlines;    
    switch (index)
    {
        case 9:
            outlines = ApplyLaplacian_3x3(s_array);
            break;
        case 25:
            outlines = ApplyLaplacian_5x5(s_array);
            break;
        case 49:
            outlines = ApplyLaplacian_7x7(s_array);
            break;
        case 81:
            outlines = ApplyLaplacian_9x9(s_array);
            break;
        default:
            outlines = ApplyLaplacian_3x3(s_array);
    }

    // Write to the final target
    Result[COORD_TEXTURE2D_X(pixelCoord)] = outlines;
}
*/

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)] // Image should ba multiple of 32
void MAIN_LAPLACIAN(uint2 groupId : SV_GroupID, // ID of thread group; range depends on Dispatch call.
                    uint2 groupThreadId : SV_GroupThreadID, // ID of thread in a thread group; range depends on numthreads.
                    uint3 dispatchThreadId : SV_DispatchThreadID) // = SV_GroupID * numthreads + SV_GroupThreadID.
{
    /*
    // Upper-left pixel coordinate of quad that this thread will read
    int2 threadUL = (groupThreadId << 1) + (groupId << 3) - 4;
    uint2 uthreadUL = uint2(max(0, threadUL));

    uint2 size = uint2(_Size.xy) - 1u;
    float4 p00 = Source[COORD_TEXTURE2D_X(min(uthreadUL + uint2(0u, 0u), size))];
    float4 p10 = Source[COORD_TEXTURE2D_X(min(uthreadUL + uint2(1u, 0u), size))];
    float4 p11 = Source[COORD_TEXTURE2D_X(min(uthreadUL + uint2(1u, 1u), size))];
    float4 p01 = Source[COORD_TEXTURE2D_X(min(uthreadUL + uint2(0u, 1u), size))];

    // Store the 4 downsampled pixels in LDS
    uint destIdx = groupThreadId.x + (groupThreadId.y << 4u);
    Store2Pixels(destIdx, p00, p10);
    Store2Pixels(destIdx + 8u, p01, p11);

    GroupMemoryBarrierWithGroupSync();
    
    uint row = groupThreadId.y << 4u;
    // uint column = groupThreadId.x << 4u;
    uint2 currentRowColumn;
    currentRowColumn.x = row.x + (groupThreadId.x << 1u), row + groupThreadId.x + (groupThreadId.x & 4u);
    currentRowColumn.y = (groupThreadId.y << 3u) + groupThreadId.x;
    DetectEdges(dispatchThreadId.xy, currentRowColumn, 9);
    */

    float2 texelSize = float2(1.0 / _Size.xy);
    float2 uv = float2(dispatchThreadId.xy * texelSize);

    laplacian = laplacian_3x3_0;
    float4 outline_edge = float4(0, 0, 0, 0);
    UNITY_UNROLL
    for (uint i = 0; i <= sample_size; ++i)
    {
        outline_edge += (SAMPLE_TEXTURE2D_X_LOD(Source, sampler_LinearClamp, uv + sample_coords[i], 0) * laplacian[i]);
    }

    Result[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(normalize(outline_edge));
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MAIN_COMPOSITE(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    if ((float)dispatchThreadId.x >= _Size.x || (float)dispatchThreadId.y >= _Size.y)
        return;

    float2 texelSize = float2(1.0 / _Size.xy);
    float2 uv = float2(dispatchThreadId.xy * texelSize);

    Result[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(SAMPLE_TEXTURE2D_X_LOD(Source, sampler_LinearClamp, uv, 0).rgb, 0) + SAMPLE_TEXTURE2D_X_LOD(CameraTex, sampler_LinearClamp, uv, 0);
}
