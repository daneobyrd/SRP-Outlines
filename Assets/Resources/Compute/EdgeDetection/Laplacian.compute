#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel KLaplacian                           GROUP_SIZE=32   MAIN_LAPLACIAN=KLaplacian
#pragma kernel KComposite                           GROUP_SIZE=8   MAIN_COMPOSITE=KComposite
// #define REGION_PER_THREAD 8

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Assets/Resources/RenderPass/XRInclude/TextureXR.hlsl"
#include "LaplacianFilters.hlsl"
#include "ComputeSampleArrays.hlsl"

CBUFFER_START(cb)
float4 _Size; // x: src width, y: src height, zw: unused
uint selectedKernel;
CBUFFER_END

TEXTURE2D(Source);
RW_TEXTURE2D(float4, Result);
TEXTURE2D(CameraTex);

SamplerState sampler_LinearClamp;

uint sample_size;
float laplacian[9];
uint2 sample_points[9];

// 16x16 pixels with an 8x8 center that we will be blurring writing out. Each uint is two color
// channels packed together.
// The reason for separating channels is to reduce bank conflicts in the local data memory
// controller. A large stride will cause more threads to collide on the same memory bank.
groupshared uint gs_cacheR[128];
groupshared uint gs_cacheG[128];
groupshared uint gs_cacheB[128];
groupshared uint gs_cacheA[128];

/*
    ┌────┬────┬────┐    ┌─────┬─────┬─────┐    ┌────┬────┬────┐
    │ 00 │ 01 │ 02 │    │  f0 │  f2 │  f3 │    │ f3 │ f2 │ f3 │
    ├────┼────┼────┤    └─────┴─────┴─────┘    ├────┼────┼────┤
    │ 03 │ 04 │ 05 │      filter[3]            │ f2 │ f0 │ f2 │
    ├────┼────┼────┤      f0 = center          ├────┼────┼────┤
    │ 06 │ 07 │ 08 │      f1 = edge            │ f3 │ f2 │ f3 │
    └────┴────┴────┘      f2 = corner          └────┴────┴────┘
*/
float4 ApplyLaplacian_3x3(uint index)
{
    return filter_3x3_0[index + 0] * (sample_3x3[4])
         + filter_3x3_0[index + 1] * (sample_3x3[1] + sample_3x3[3] + sample_3x3[5] + sample_3x3[7])
         + filter_3x3_0[index + 2] * (sample_3x3[0] + sample_3x3[2] + sample_3x3[6] + sample_3x3[8]);
}

/*
    ┌────┬────┬────┬────┬────┐                              ╔════╗••••••••••••••••••••
    │ 00 │ 01 │ 02 │ 03 │ 04 │    filter[6]:                ║ f5 ║ f4 • f3 • f4 • f5 •
    ├────┼────┼────┼────┼────┤    only need 6 values        ╠════╬════╗•••••••••••••••
    │ 05 │ 06 │ 07 │ 08 │ 09 │    f0 = center               ║ f4 ║ f2 ║ f1 • f2 • f4 •
    ├────┼────┼────┼────┼────┤    f1 = inner edge           ╠════╬════╬════╗••••••••••
    │ 10 │ 11 │ 12 │ 13 │ 14 │    f2 = inner corner         ║ f3 ║ f1 ║ f0 ║ f1 • f3 •
    ├────┼────┼────┼────┼────┤                              ╚════╩════╩════╝••••••••••
    │ 15 │ 16 │ 17 │ 18 │ 19 │    f3 = outer edge           • f4 • f2 • f1 • f2 • f4 •
    ├────┼────┼────┼────┼────┤    f4 = outer edge adjacent  ••••••••••••••••••••••••••
    │ 20 │ 21 │ 22 │ 23 │ 24 │    f5 = outer corner         • f5 • f4 • f3 • f4 • f5 •
    └────┴────┴────┴────┴────┘                              ••••••••••••••••••••••••••
*/
float4 ApplyLaplacian_5x5(uint index)
{
    const float4 center   = filter_5x5_0[index + 0] * (sample_5x5[12]);
    const float4 edge_0   = filter_5x5_0[index + 1] * (sample_5x5[7] + sample_5x5[11] + sample_5x5[13] + sample_5x5[17]);
    const float4 corner_0 = filter_5x5_0[index + 2] * (sample_5x5[6] + sample_5x5[8] + sample_5x5[16] + sample_5x5[18]);
    
    const float4 edge_1a  = filter_5x5_0[index + 3] * (sample_5x5[2] + sample_5x5[10] + sample_5x5[14] + sample_5x5[22]);
    const float4 edge_1b  = filter_5x5_0[index + 4] * (sample_5x5[1] + sample_5x5[3] + sample_5x5[05] + sample_5x5[9] + sample_5x5[15] + sample_5x5[19] + sample_5x5[21] + sample_5x5[23]);
    const float4 corner_1 = filter_5x5_0[index + 5] * (sample_5x5[0] + sample_5x5[4] + sample_5x5[20] + sample_5x5[24]);
    
    return
        center + edge_0 + corner_0
        + edge_1a + edge_1b + corner_1;
}

float4 ApplyLaplacian_7x7(uint index)
{
    const float4 center   = filter_7x7_0[index + 0] * (sample_7x7[25]);
    const float4 edge_0   = filter_7x7_0[index + 1] * (sample_7x7[18] + sample_7x7[24] + sample_7x7[26] + sample_7x7[32]);
    const float4 corner_0 = filter_7x7_0[index + 2] * (sample_7x7[17] + sample_7x7[19] + sample_7x7[31] + sample_7x7[33]);
    
    const float4 edge_1a  = filter_7x7_0[index + 3] * (sample_7x7[10] + sample_7x7[23] + sample_7x7[27] + sample_7x7[38]);
    const float4 edge_1b  = filter_7x7_0[index + 4] * (sample_7x7[9] + sample_7x7[11] + sample_7x7[15] + sample_7x7[19] + sample_7x7[29] + sample_7x7[33] + sample_7x7[37] + sample_7x7[39]);
    const float4 corner_1 = filter_7x7_0[index + 5] * (sample_7x7[8] + sample_7x7[12] + sample_7x7[36] + sample_7x7[40]);

    const float4 edge_2a  = filter_7x7_0[index + 6] + (sample_7x7[3] + sample_7x7[21] + sample_7x7[27] + sample_7x7[45]);
    const float4 edge_2b  = filter_7x7_0[index + 7] + (sample_7x7[2] + sample_7x7[4] + sample_7x7[14] + sample_7x7[20] + sample_7x7[28] + sample_7x7[34] + sample_7x7[44] + sample_7x7[46]);
    const float4 edge_2c  = filter_7x7_0[index + 8] + (sample_7x7[1] + sample_7x7[5] + sample_7x7[7] + sample_7x7[13] + sample_7x7[35] + sample_7x7[41] + sample_7x7[43] + sample_7x7[47]);
    const float4 corner_2 = filter_7x7_0[index + 9] + (sample_7x7[0] + sample_7x7[6] + sample_7x7[42] + sample_7x7[48]);
    
    return
        center + edge_0 + corner_0
        + edge_1a + edge_1b + corner_1
        + edge_2a + edge_2b + edge_2c + corner_2;
}

float4 ApplyLaplacian_9x9(uint index) // outer rim is currently "0" padding
{
    const float4 center   = filter_9x9_0[index + 0] * (sample_9x9[40]);
    const float4 edge_0   = filter_9x9_0[index + 1] * (sample_9x9[31] + sample_9x9[39] + sample_9x9[41] + sample_9x9[49]);
    const float4 corner_0 = filter_9x9_0[index + 2] * (sample_9x9[30] + sample_9x9[32] + sample_9x9[48] + sample_9x9[50]);
    
    const float4 edge_1a  = filter_9x9_0[index + 3] * (sample_9x9[22] + sample_9x9[38] + sample_9x9[42] + sample_9x9[58]);
    const float4 edge_1b  = filter_9x9_0[index + 4] * (sample_9x9[21] + sample_9x9[23] + sample_9x9[29] + sample_9x9[33] + sample_9x9[47] + sample_9x9[51] + sample_9x9[57] + sample_9x9[59]);
    const float4 corner_1 = filter_9x9_0[index + 5] * (sample_9x9[20] + sample_9x9[24] + sample_9x9[56] + sample_9x9[60]);

    const float4 edge_2a  = filter_9x9_0[index + 6] + (sample_9x9[13] + sample_9x9[37] + sample_9x9[43] + sample_9x9[67]);
    const float4 edge_2b  = filter_9x9_0[index + 7] + (sample_9x9[12] + sample_9x9[14] + sample_9x9[28] + sample_9x9[34] + sample_9x9[46] + sample_9x9[52] + sample_9x9[66] + sample_9x9[68]);
    const float4 edge_2c  = filter_9x9_0[index + 8] + (sample_9x9[11] + sample_9x9[15] + sample_9x9[19] + sample_9x9[25] + sample_9x9[55] + sample_9x9[61] + sample_9x9[65] + sample_9x9[69]);
    const float4 corner_2 = filter_9x9_0[index + 9] + (sample_9x9[10] + sample_9x9[16] + sample_9x9[64] + sample_9x9[70]);

    const float4 edge_3a  = (sample_9x9[4] + sample_9x9[36] + sample_9x9[44] + sample_9x9[76]);
    const float4 edge_3b  = (sample_9x9[3] + sample_9x9[5] + sample_9x9[27] + sample_9x9[35] + sample_9x9[45] + sample_9x9[53] + sample_9x9[75] + sample_9x9[77]);
    const float4 edge_3c  = (sample_9x9[2] + sample_9x9[6] + sample_9x9[18] + sample_9x9[26] + sample_9x9[54] + sample_9x9[62] + sample_9x9[74] + sample_9x9[78]);
    const float4 edge_3d  = (sample_9x9[1] + sample_9x9[7] + sample_9x9[9] + sample_9x9[17] + sample_9x9[63] + sample_9x9[71] + sample_9x9[73] + sample_9x9[79]);
    const float4 corner_3 = (sample_9x9[0] + sample_9x9[8] + sample_9x9[72] + sample_9x9[80]);

    return
        center + edge_0 + corner_0
        + edge_1a + edge_1b + corner_1
        + edge_2a + edge_2b + edge_2c + corner_2
        + edge_3a + edge_3b + edge_3c + edge_3d + corner_3;
}

void Store2Pixels(uint index, float4 pixel1, float4 pixel2)
{
    gs_cacheR[index] = f32tof16(pixel1.r) | f32tof16(pixel2.r) << 16;
    gs_cacheG[index] = f32tof16(pixel1.g) | f32tof16(pixel2.g) << 16;
    gs_cacheB[index] = f32tof16(pixel1.b) | f32tof16(pixel2.b) << 16;
    gs_cacheA[index] = f32tof16(pixel1.a) | f32tof16(pixel2.a) << 16;
}

void Load2Pixels(uint index, out float4 pixel1, out float4 pixel2)
{
    uint rr = gs_cacheR[index];
    uint gg = gs_cacheG[index];
    uint bb = gs_cacheB[index];
    uint aa = gs_cacheA[index];
    pixel1 = float4(f16tof32(rr), f16tof32(gg), f16tof32(bb), f16tof32(aa));
    pixel2 = float4(f16tof32(rr >> 16), f16tof32(gg >> 16), f16tof32(bb >> 16), f16tof32(aa >> 16));
}

void Store1Pixel(uint index, float4 pixel)
{
    gs_cacheR[index] = asuint(pixel.r);
    gs_cacheG[index] = asuint(pixel.g);
    gs_cacheB[index] = asuint(pixel.b);
    gs_cacheA[index] = asuint(pixel.a);
}

void Load1Pixel(uint index, out float4 pixel)
{
    pixel = asfloat(uint4(gs_cacheR[index], gs_cacheG[index], gs_cacheB[index], gs_cacheA[index]));
}

// Blur two pixels horizontally.  This reduces LDS reads and pixel unpacking.
void DetectEdges_Horizontal(uint outIndex, uint leftMostIndex)
{
    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
    Load2Pixels(leftMostIndex + 0, s0, s1);
    Load2Pixels(leftMostIndex + 1, s2, s3);
    Load2Pixels(leftMostIndex + 2, s4, s5);
    Load2Pixels(leftMostIndex + 3, s6, s7);
    Load2Pixels(leftMostIndex + 4, s8, s9);

    Store1Pixel(outIndex, ApplyLaplacian_9x9(0));
    Store1Pixel(outIndex + 1, ApplyLaplacian_9x9(1));
}

void DetectEdges_Vertical(uint2 pixelCoord, uint topMostIndex)
{
    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8;
    Load1Pixel(topMostIndex, s0);
    Load1Pixel(topMostIndex + 8, s1);
    Load1Pixel(topMostIndex + 16, s2);
    Load1Pixel(topMostIndex + 24, s3);
    Load1Pixel(topMostIndex + 32, s4);
    Load1Pixel(topMostIndex + 40, s5);
    Load1Pixel(topMostIndex + 48, s6);
    Load1Pixel(topMostIndex + 56, s7);
    Load1Pixel(topMostIndex + 64, s8);

    float4 outlines = ApplyLaplacian_9x9(0);

    // Write to the final target
    Result[COORD_TEXTURE2D_X(pixelCoord)] = outlines;
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]                             // Image should ba multiple of 32
void MAIN_LAPLACIAN(uint2 groupId : SV_GroupID,                     // ID of thread group; range depends on Dispatch call.
                    uint2 groupThreadId : SV_GroupThreadID,         // ID of thread in a thread group; range depends on numthreads.
                    uint3 dispatchThreadID : SV_DispatchThreadID)   // = SV_GroupID * numthreads + SV_GroupThreadID.
{


    float2 texelSize = float2(1.0 / _Size.xy);
    float2 uv = float2(dispatchThreadID.xy * texelSize);

    float4 outline_edge = float4(0, 0, 0, 0);
    // UNITY_UNROLL
    for (uint i = 0; i <= sample_size; ++i)
    {
        outline_edge += Source.SampleLevel(sampler_LinearClamp, uv + sample_points[i], 0) * laplacian[i];
    }

    Result[dispatchThreadID.xy] = float4(normalize(outline_edge));
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MAIN_COMPOSITE(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if (dispatchThreadID.x >= _Size.x || dispatchThreadID.y >= _Size.y)
        return;
    
    float2 texelSize = float2(1.0 / _Size.xy);
    float2 uv = float2(dispatchThreadID.xy * texelSize);

    Result[dispatchThreadID.xy] = float4(Source.SampleLevel(sampler_LinearClamp, uv, 0).rgb, 0) + CameraTex.SampleLevel(sampler_LinearClamp, uv, 0);
}
