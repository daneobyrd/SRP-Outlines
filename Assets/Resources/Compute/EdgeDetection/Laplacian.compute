#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel KLaplacian                           GROUP_SIZE=32   MAIN_LAPLACIAN=KLaplacian
#pragma kernel KComposite                           GROUP_SIZE=8    MAIN_COMPOSITE=KComposite
// #define REGION_PER_THREAD 8

#include "LaplacianFilters.hlsl"

TEXTURE2D(Source);
RW_TEXTURE2D(float4, Result);
TEXTURE2D(CameraTex);
RW_TEXTURE2D(float4, Final);

SamplerState sampler_LinearClamp;


/*
float SobelEdge(float2 coord, float threshold, float thickness)
{
    /*
     *Sobel 3x3 tap filter: approximate magnitude
    Cheaper than the full Sobel kernel evaluation
    https://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm
    ────────────┬────────────────
    p1  p2  p3  │ x
    p4 (p5) p6  │ convolution kernel
    p7  p8  p9  │
    ────────────┴────────────────
    Gx  = pow((p1 + 2 * p2 + p3) - (p7 + 2 * p8 + p9), 2);
    ────────────┬────────────────
    p3  p6  p9  │ y (x rotated counter cw)
    p2 (p5) p8  │ convolution kernel
    p1  p4  p7  │
    ────────────┴────────────────
    Gy  = pow((p3 + 2 * p6 + p9) - (p1 + 2 * p4 + p7), 2);
    ─────────────────────────────
    Formula:
    |G| = |Gx|² + |Gy|² => pow(G,2) = Gx*Gx + Gy*Gy
    |G| = |(p1 + 2 * p2 + p3) - (p7 + 2 * p8 + p9)| + 
          |(p3 + 2 * p6 + p9) - (p1 + 2 * p4 + p7)|
    p5 == current pixel, 
    sample neighbors to create 3x3 kernel
    #1#
    float p1 = Luminance(Source[uint2(coord + float2(-thickness, -thickness))]);
    float p2 = Luminance(Source[uint2(coord + float2(0, -thickness))]);
    float p3 = Luminance(Source[uint2(coord + float2(thickness, -thickness))]);

    float p4 = Luminance(Source[uint2(coord + float2(-thickness, 0))]);

    float p6 = Luminance(Source[uint2(coord + float2(thickness, 0))]);

    float p7 = Luminance(Source[uint2(coord + float2(-thickness, thickness))]);
    float p8 = Luminance(Source[uint2(coord + float2(0, thickness))]);
    float p9 = Luminance(Source[uint2(coord + float2(thickness, thickness))]);
    //float sobelX = (p1 + 2 * p2 + p3) - (p7 + 2 * p8 + p9);
    //float sobelY = (p3 + 2 * p6 + p9) - (p1 + 2 * p4 + p7);
    float sobelX = mad(2, p2, p1 + p3) - mad(2, p8, p7 + p9);
    float sobelY = mad(2, p6, p3 + p9) - mad(2, p4, p1 + p7);
    float edgeSqr = (sobelX * sobelX + sobelY * sobelY);
    float result = 1.0 - (edgeSqr > threshold * threshold);
    // if (edgeSqr > threshold * threshold) { is edge }
    return result; // black (0) = edge, otherwise white (1)
} // End SobelEdge
*/

// 16x16 pixels with an 8x8 center that we will be edge-detecting.
/* Each uint is two color channels packed together.
    ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼─ ╔══╦══╦══╦══╦══╦══╦══╦══╗ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╚══╩══╩══╩══╩══╩══╩══╩══╝ ─┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘       */
// The reason for separating channels is to reduce bank conflicts in the local data memory
// controller. A large stride will cause more threads to collide on the same memory bank.
/*
groupshared uint gs_cacheR[128];
groupshared uint gs_cacheG[128];
groupshared uint gs_cacheB[128];
groupshared uint gs_cacheA[128];


// TODO: This is not correct, untested placeholder mutation of blur function with laplacian filter.
float4 DetectEdges(float4 a, float4 b, float4 c, float4 d, float4 e, float4 f, float4 g, float4 h, float4 i)
{                           
    return (24 * e)
    + -(d)
    + -(f)              
    + -(c)
    + -(g)
    + -(b)
    + -(h)
    + -(a)
    + -(i);       
}                           

void Store2Pixels(uint index, float4 pixel1, float4 pixel2)
{
    gs_cacheR[index] = f32tof16(pixel1.r) | f32tof16(pixel2.r) << 16;
    gs_cacheG[index] = f32tof16(pixel1.g) | f32tof16(pixel2.g) << 16;
    gs_cacheB[index] = f32tof16(pixel1.b) | f32tof16(pixel2.b) << 16;
    gs_cacheA[index] = f32tof16(pixel1.a) | f32tof16(pixel2.a) << 16;
}

void Load2Pixels(uint index, out float4 pixel1, out float4 pixel2)
{
    uint rr = gs_cacheR[index];
    uint gg = gs_cacheG[index];
    uint bb = gs_cacheB[index];
    uint aa = gs_cacheA[index];
    pixel1 = float4(f16tof32(rr), f16tof32(gg), f16tof32(bb), f16tof32(aa));
    pixel2 = float4(f16tof32(rr >> 16), f16tof32(gg >> 16), f16tof32(bb >> 16), f16tof32(aa >> 16));
}

void Store1Pixel(uint index, float4 pixel)
{
    gs_cacheR[index] = asuint(pixel.r);
    gs_cacheG[index] = asuint(pixel.g);
    gs_cacheB[index] = asuint(pixel.b);
    gs_cacheA[index] = asuint(pixel.a);
}

void Load1Pixel(uint index, out float4 pixel)
{
    pixel = asfloat(uint4(gs_cacheR[index], gs_cacheG[index], gs_cacheB[index], gs_cacheA[index]));
}

// Detect two pixels horizontally. This reduces LDS reads and pixel unpacking.
void DetectEdgesHorizontally(uint outIndex, uint leftMostIndex)
{
    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
    Load2Pixels(leftMostIndex + 0, s0, s1);
    Load2Pixels(leftMostIndex + 1, s2, s3);
    Load2Pixels(leftMostIndex + 2, s4, s5);
    Load2Pixels(leftMostIndex + 3, s6, s7);
    Load2Pixels(leftMostIndex + 4, s8, s9);

    Store1Pixel(outIndex, DetectEdges(s0, s1, s2, s3, s4, s5, s6, s7, s8));
    Store1Pixel(outIndex + 1, DetectEdges(s1, s2, s3, s4, s5, s6, s7, s8, s9));
}

void DetectEdgesVertically(uint2 pixelCoord, uint topMostIndex)
{
    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8;
    Load1Pixel(topMostIndex, s0);
    Load1Pixel(topMostIndex + 8, s1);
    Load1Pixel(topMostIndex + 16, s2);
    Load1Pixel(topMostIndex + 24, s3);
    Load1Pixel(topMostIndex + 32, s4);
    Load1Pixel(topMostIndex + 40, s5);
    Load1Pixel(topMostIndex + 48, s6);
    Load1Pixel(topMostIndex + 56, s7);
    Load1Pixel(topMostIndex + 64, s8);

    float4 edges = DetectEdges(s0, s1, s2, s3, s4, s5, s6, s7, s8);

    // Write to the final target
    result[pixelCoord] = edges;
}
*/

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)] // Image should ba multiple of 32
void MAIN_LAPLACIAN(uint2 groupId : SV_GroupID, // ID of thread group; range depends on Dispatch call.
                    uint2 groupThreadId : SV_GroupThreadID, // ID of thread in a thread group; range depends on numthreads.
                    uint3 dispatchThreadID : SV_DispatchThreadID) // = SV_GroupID * numthreads + SV_GroupThreadID.
{
    // Upper-left pixel coordinate of quad that this thread will read.
    /*
    int2 threadUL = (groupThreadId << 1) + (groupId << 3) - 4; 
    uint2 uthreadUL = uint2(max(0, threadUL));

    uint2 size = uint2(_Size.xy) - 1u;                                          // ┌─────┬─────┐
    float4 p00 = source[min(uthreadUL + uint2(0u, 0u), size)];                  // │ p00 │ p01 │
    float4 p10 = source[min(uthreadUL + uint2(1u, 0u), size)];                  // ├─────┼─────┤
    float4 p11 = source[min(uthreadUL + uint2(1u, 1u), size)];                  // │ p10 │ p11 │
    float4 p01 = source[min(uthreadUL + uint2(0u, 1u), size)];                  // └─────┴─────┘

    // Store the 4 downsampled pixels in LDS.
    uint destIdx = groupThreadId.x + (groupThreadId.y << 4u);
    Store2Pixels(destIdx, p00, p10);
    Store2Pixels(destIdx + 8u, p01, p11);

    GroupMemoryBarrierWithGroupSync();

    // Horizontally detect edges of the pixels in LDS.
    uint row = groupThreadId.y << 4u;
    */

    //────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
    set_laplacian();
    
    float2 texelSize = float2(1.0 / _Size.xy);
    float2 uv = float2(dispatchThreadID.xy * texelSize);
    
    float4 outline_edge = float4(0, 0, 0, 0);
    // UNITY_UNROLL
    for (uint i = 0; i <= sample_size; ++i)
    {
        outline_edge += Source.SampleLevel(sampler_LinearClamp, uv + sample_points[i], 0) * laplacian[i];
    }

    // float4 sum = float4(0, 0, 0, 0);
    // 9 sample
    // Top row
    // sum += Source.SampleLevel(sampler_LinearClamp, uv + float2( -texelSize.x,  texelSize.y ), 0).rgb * -1; // -1_1
    // sum += Source.SampleLevel(sampler_LinearClamp, uv + float2(  0,  texelSize.y ), 0).rgb * -1;           // 0_1
    // sum += Source.SampleLevel(sampler_LinearClamp, uv + float2(  texelSize.x,  texelSize.y ), 0).rgb * -1; // 1_1
    // Center row
    // sum += Source.SampleLevel(sampler_LinearClamp, uv + float2( -texelSize.x,  0 ), 0).rgb * -1; // -1_0
    // sum += Source.SampleLevel(sampler_LinearClamp, uv + float2(  0,  0 ), 0).rgb * 8;  // 0_0
    // sum += Source.SampleLevel(sampler_LinearClamp, uv + float2(  texelSize.x,  0 ), 0).rgb * -1; // 1_0
    // Bottom row
    // sum += Source.SampleLevel(sampler_LinearClamp, uv + float2(-texelSize.x, -texelSize.y), 0).rgb * -1; // -1_-1
    // sum += Source.SampleLevel(sampler_LinearClamp, uv + float2(0, -texelSize.y), 0).rgb * -1; // 0_-1
    // sum += Source.SampleLevel(sampler_LinearClamp, uv + float2(texelSize.x, -texelSize.y), 0).rgb * -1; // 1_1

    Result[dispatchThreadID.xy] = float4(normalize(outline_edge));
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MAIN_COMPOSITE(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    float2 texelSize = float2(1.0 / _Size.xy);
    float2 uv = float2(dispatchThreadID.xy * texelSize);

    Final[dispatchThreadID.xy] = Source.SampleLevel(sampler_LinearClamp, uv + float2(dispatchThreadID.xy) / _Size.xy,0)
                 + CameraTex.SampleLevel(sampler_LinearClamp, uv + float2(dispatchThreadID.xy) / _Size.xy, 0);
}
