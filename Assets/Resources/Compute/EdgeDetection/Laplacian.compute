#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel KLaplacian                           GROUP_SIZE=32   MAIN_LAPLACIAN=KLaplacian

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.universal/Shaders/PostProcessing/Common.hlsl"
#include "LaplacianFilters.hlsl"

CBUFFER_START(cb)
float4 _Size; // x: src width, y: src height, zw: unused
CBUFFER_END

TEXTURE2D(Source);
RW_TEXTURE2D(float4, Result);

const static int sample_size = 9;
float laplacian[9];
const static int2 offsets[9] =
{
    int2(-1, 1),  int2(0, 1),  int2(1, 1),
    int2(-1, 0),  int2(0, 0),  int2(1, 0),
    int2(-1, -1), int2(0, -1), int2(1, -1)
};

/*
// 16x16 pixels with an 8x8 center that we will be blurring writing out. Each uint is two color
// channels packed together.
// The reason for separating channels is to reduce bank conflicts in the local data memory
// controller. A large stride will cause more threads to collide on the same memory bank.
groupshared uint gs_cacheR[128];
groupshared uint gs_cacheG[128];
groupshared uint gs_cacheB[128];
groupshared uint gs_cacheA[128];

void Store2Pixels(uint index, float4 pixel1, float4 pixel2)
{
    gs_cacheR[index] = f32tof16(pixel1.r) | f32tof16(pixel2.r) << 16;
    gs_cacheG[index] = f32tof16(pixel1.g) | f32tof16(pixel2.g) << 16;
    gs_cacheB[index] = f32tof16(pixel1.b) | f32tof16(pixel2.b) << 16;
    gs_cacheA[index] = f32tof16(pixel1.a) | f32tof16(pixel2.a) << 16;
}

void Load2Pixels(uint index, out float4 pixel1, out float4 pixel2)
{
    uint rr = gs_cacheR[index];
    uint gg = gs_cacheG[index];
    uint bb = gs_cacheB[index];
    uint aa = gs_cacheA[index];
    pixel1 = float4(f16tof32(rr), f16tof32(gg), f16tof32(bb), f16tof32(aa));
    pixel2 = float4(f16tof32(rr >> 16), f16tof32(gg >> 16), f16tof32(bb >> 16), f16tof32(aa >> 16));
}

void Store1Pixel(uint index, float4 pixel)
{
    gs_cacheR[index] = asuint(pixel.r);
    gs_cacheG[index] = asuint(pixel.g);
    gs_cacheB[index] = asuint(pixel.b);
    gs_cacheA[index] = asuint(pixel.a);
}

void Load1Pixel(uint index, out float4 pixel)
{
    pixel = asfloat(uint4(gs_cacheR[index], gs_cacheG[index], gs_cacheB[index], gs_cacheA[index]));
}

void DetectEdges(uint2 pixelCoord, uint topLeftMostIndex, uint index)
{
    if (index == 0) { index = 9; }
    float4 s_array[9];
    for (uint i = 0; i < index; i++)
    {
        float4 current, next;
        Load2Pixels(topLeftMostIndex + i, current, next);
        s_array[i] = current;
        s_array[i + 1] = next;
    }
    
    float4 outlines;
    #if LAPLACIAN_KERNEL == 30
            outlines = ApplyLaplacian_3x3(s_array, laplace_3x3_0);
    #elif LAPLACIAN_KERNEL == 31
            outlines = ApplyLaplacian_3x3(s_array, laplace_3x3_1);
    #elif LAPLACIAN_KERNEL == 32
            outlines = ApplyLaplacian_3x3(s_array, laplace_3x3_2);
    #elif LAPLACIAN_KERNEL == 33
            outlines = ApplyLaplacian_3x3(s_array, laplace_3x3_3);
    #elif LAPLACIAN_KERNEL == 50
            outlines = ApplyLaplacian_5x5(s_array, laplace_5x5_0);
    #elif LAPLACIAN_KERNEL == 51
            outlines = ApplyLaplacian_5x5(s_array, laplace_5x5_1);
    #elif LAPLACIAN_KERNEL == 70
        outlines = ApplyLaplacian_7x7(s_array, laplace_7x7_0);
    #elif LAPLACIAN_KERNEL == 90
        outlines = ApplyLaplacian_9x9(s_array, laplace_9x9_0);
    #else
        outlines = ApplyLaplacian_3x3(s_array, laplace_3x3_0);
    #endif
    
    // Write to the final target
    Result[pixelCoord] = outlines;
}*/

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]                             // Image should ba multiple of 32
void MAIN_LAPLACIAN(uint2 groupId : SV_GroupID,                     // ID of thread group; range depends on Dispatch call.
                    uint2 groupThreadId : SV_GroupThreadID,         // ID of thread in a thread group; range depends on numthreads.
                    uint3 dispatchThreadId : SV_DispatchThreadID)   // = SV_GroupID * numthreads + SV_GroupThreadID.
{
    /*
    // Upper-left pixel coordinate of quad that this thread will read
    int2 threadUL = (groupThreadId << 1) + (groupId << 3) - 4;
    uint2 uthreadUL = uint2(max(0, threadUL));

    uint2 size = uint2(_Size.xy) - 1u;
    float4 p00 = Source[min(uthreadUL + uint2(0u, 0u), size)];
    float4 p10 = Source[min(uthreadUL + uint2(1u, 0u), size)];
    float4 p11 = Source[min(uthreadUL + uint2(1u, 1u), size)];
    float4 p01 = Source[min(uthreadUL + uint2(0u, 1u), size)];

    // Store the 4 downsampled pixels in LDS
    uint destIdx = groupThreadId.x + (groupThreadId.y << 4u);
    Store2Pixels(destIdx, p00, p10);
    Store2Pixels(destIdx + 8u, p01, p11);

    GroupMemoryBarrierWithGroupSync();
    
    uint row = groupThreadId.y << 4u;
    // uint column = groupThreadId.x << 4u;
    uint2 currentRowColumn;
    currentRowColumn.x = row.x + (groupThreadId.x << 1u), row + groupThreadId.x + (groupThreadId.x & 4u);
    currentRowColumn.y = (groupThreadId.y << 3u) + groupThreadId.x;
    DetectEdges(dispatchThreadId.xy, currentRowColumn, 9);
    */

    float2 texelSize = float2(1.0 / _Size.xy);
    float2 uv = float2(dispatchThreadId.xy * texelSize);

    laplacian = laplacian_3x3_0;
    float3 outline_edge = float3(0, 0, 0);
    UNITY_UNROLL
    for(int i = 0; i < sample_size; i++)
    {
        outline_edge += Source.SampleLevel(sampler_LinearClamp, uv + float2(texelSize * offsets[i]), 0).rgb * laplacian[i];
    }
    
    Result[(dispatchThreadId.xy)] = float4(outline_edge, 1);
}