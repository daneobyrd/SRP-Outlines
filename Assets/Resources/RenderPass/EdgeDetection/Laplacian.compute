#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel MAIN_LAPLACIAN
#define GROUP_SIZE 32
// #define REGION_PER_THREAD 8


// Sobel based on https://www.shadertoy.com/view/Xdf3Rf by Jeroen Baert

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
// #include "Laplacian.hlsl"
// ↑ _kernel_size;
// ↑ _kernel_type;

Texture2D<float4> source;
RWTexture2D<float4> result;
SamplerState sampler_LinearClamp;

CBUFFER_START(cb)
float4 _Size; // x: src width, y: src height, zw: unused
CBUFFER_END

// 16x16 pixels with an 8x8 center that we will be edge-detecting.
/* Each uint is two color channels packed together.
    ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼─ ╔══╦══╦══╦══╦══╦══╦══╦══╗ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╠══╬══╬══╬══╬══╬══╬══╬══╣ ─┼──┼──┼──┤
    ├──┼──┼──┼─ ╚══╩══╩══╩══╩══╩══╩══╩══╝ ─┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
    └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘       */
// The reason for separating channels is to reduce bank conflicts in the local data memory
// controller. A large stride will cause more threads to collide on the same memory bank.
/*
groupshared uint gs_cacheR[128];
groupshared uint gs_cacheG[128];
groupshared uint gs_cacheB[128];
groupshared uint gs_cacheA[128];


// TODO: This is not correct, untested placeholder mutation of blur function.
float4 DetectEdges(float4 a, float4 b, float4 c, float4 d, float4 e, float4 f, float4 g, float4 h, float4 i)
{                           
    return (24 * e)
    + -(d)
    + -(f)              
    + -(c)
    + -(g)
    + -(b)
    + -(h)
    + -(a)
    + -(i);         
}                           

void Store2Pixels(uint index, float4 pixel1, float4 pixel2)
{
    gs_cacheR[index] = f32tof16(pixel1.r) | f32tof16(pixel2.r) << 16;
    gs_cacheG[index] = f32tof16(pixel1.g) | f32tof16(pixel2.g) << 16;
    gs_cacheB[index] = f32tof16(pixel1.b) | f32tof16(pixel2.b) << 16;
    gs_cacheA[index] = f32tof16(pixel1.a) | f32tof16(pixel2.a) << 16;
}

void Load2Pixels(uint index, out float4 pixel1, out float4 pixel2)
{
    uint rr = gs_cacheR[index];
    uint gg = gs_cacheG[index];
    uint bb = gs_cacheB[index];
    uint aa = gs_cacheA[index];
    pixel1 = float4(f16tof32(rr), f16tof32(gg), f16tof32(bb), f16tof32(aa));
    pixel2 = float4(f16tof32(rr >> 16), f16tof32(gg >> 16), f16tof32(bb >> 16), f16tof32(aa >> 16));
}

void Store1Pixel(uint index, float4 pixel)
{
    gs_cacheR[index] = asuint(pixel.r);
    gs_cacheG[index] = asuint(pixel.g);
    gs_cacheB[index] = asuint(pixel.b);
    gs_cacheA[index] = asuint(pixel.a);
}

void Load1Pixel(uint index, out float4 pixel)
{
    pixel = asfloat(uint4(gs_cacheR[index], gs_cacheG[index], gs_cacheB[index], gs_cacheA[index]));
}

// Detect two pixels horizontally. This reduces LDS reads and pixel unpacking.
void DetectEdgesHorizontally(uint outIndex, uint leftMostIndex)
{
    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
    Load2Pixels(leftMostIndex + 0, s0, s1);
    Load2Pixels(leftMostIndex + 1, s2, s3);
    Load2Pixels(leftMostIndex + 2, s4, s5);
    Load2Pixels(leftMostIndex + 3, s6, s7);
    Load2Pixels(leftMostIndex + 4, s8, s9);

    Store1Pixel(outIndex, DetectEdges(s0, s1, s2, s3, s4, s5, s6, s7, s8));
    Store1Pixel(outIndex + 1, DetectEdges(s1, s2, s3, s4, s5, s6, s7, s8, s9));
}

void DetectEdgesVertically(uint2 pixelCoord, uint topMostIndex)
{
    float4 s0, s1, s2, s3, s4, s5, s6, s7, s8;
    Load1Pixel(topMostIndex, s0);
    Load1Pixel(topMostIndex + 8, s1);
    Load1Pixel(topMostIndex + 16, s2);
    Load1Pixel(topMostIndex + 24, s3);
    Load1Pixel(topMostIndex + 32, s4);
    Load1Pixel(topMostIndex + 40, s5);
    Load1Pixel(topMostIndex + 48, s6);
    Load1Pixel(topMostIndex + 56, s7);
    Load1Pixel(topMostIndex + 64, s8);

    float4 edges = DetectEdges(s0, s1, s2, s3, s4, s5, s6, s7, s8);

    // Write to the final target
    result[pixelCoord] = edges;
}
*/

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)] // Image should ba multiple of 32
void MAIN_LAPLACIAN(//uint2 groupId : SV_GroupID,                                 // ID of thread group; range depends on Dispatch call.
                    //uint2 groupThreadId : SV_GroupThreadID,                     // ID of thread in a thread group; range depends on numthreads.
                    uint3 dispatchThreadID : SV_DispatchThreadID)               // = SV_GroupID * numthreads + SV_GroupThreadID.
{
    // Upper-left pixel coordinate of quad that this thread will read.
    /*
    int2 threadUL = (groupThreadId << 1) + (groupId << 3) - 4; 
    uint2 uthreadUL = uint2(max(0, threadUL));

    uint2 size = uint2(_Size.xy) - 1u;                                          // ┌─────┬─────┐
    float4 p00 = source[min(uthreadUL + uint2(0u, 0u), size)];                  // │ p00 │ p01 │
    float4 p10 = source[min(uthreadUL + uint2(1u, 0u), size)];                  // ├─────┼─────┤
    float4 p11 = source[min(uthreadUL + uint2(1u, 1u), size)];                  // │ p10 │ p11 │
    float4 p01 = source[min(uthreadUL + uint2(0u, 1u), size)];                  // └─────┴─────┘

    // Store the 4 downsampled pixels in LDS.
    uint destIdx = groupThreadId.x + (groupThreadId.y << 4u);
    Store2Pixels(destIdx, p00, p10);
    Store2Pixels(destIdx + 8u, p01, p11);

    GroupMemoryBarrierWithGroupSync();

    // Horizontally detect edges of the pixels in LDS.
    uint row = groupThreadId.y << 4u;
    */

    //────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
    
    float2 texelSize = float2(1.0 / _Size.xy);
    float2 uv   = float2(dispatchThreadID.xy * texelSize);

    // texelSize *= _kernel_size;
    
    // Laplacian filer (see http://en.wikipedia.org/wiki/Laplace_operator)
    //          ┌─────┬─────┬─────┐           ┌─────┬─────┬─────┐
    //          │  0  │ -1  │  0  │           │ -1  │ -1  │ -1  │
    //          ├─────┼─────┼─────┤           ├─────┼─────┼─────┤
    //   1, 3 = │ -1  │  4  │ -1  │    2, 3 = │ -1  │  8  │ -1  │
    //          ├─────┼─────┼─────┤           ├─────┼─────┼─────┤
    //          │  0  │ -1  │  0  │           │ -1  │ -1  │ -1  │
    //          └─────┴─────┴─────┘           └─────┴─────┴─────┘
    //                Default                  Include diagonals
    
    // for (int i = 0; i <= (_kernel_size * _kernel_size); ++i)
    // {
    //     float4 outlineEdge = float4(0, 0, 0, 1.0f);
    //     // float sum;
    //     outlineEdge += source.SampleLevel(sampler_LinearClamp, uv + sample_points[i], 0).rgb * laplace_filter[i];
    // }
    
    float3 sum = float3(0, 0, 0);
    // 9 sample
    // Top row
    sum += source.SampleLevel(sampler_LinearClamp, uv + float2( -texelSize.x,  texelSize.y ), 0).rgb * -1; // -1_1
    sum += source.SampleLevel(sampler_LinearClamp, uv + float2(  0,  texelSize.y ), 0).rgb * -1;  // 0_1
    sum += source.SampleLevel(sampler_LinearClamp, uv + float2(  texelSize.x,  texelSize.y ), 0).rgb * -1; // 1_1
    // Center row
    sum += source.SampleLevel(sampler_LinearClamp, uv + float2( -texelSize.x,  0 ), 0).rgb * -1; // -1_0
    sum += source.SampleLevel(sampler_LinearClamp, uv + float2(  0,  0 ), 0).rgb * 8;  // 0_0
    sum += source.SampleLevel(sampler_LinearClamp, uv + float2(  texelSize.x,  0 ), 0).rgb * -1; // 1_0
    // Bottom row
    sum += source.SampleLevel(sampler_LinearClamp, uv + float2( -texelSize.x, -texelSize.y ), 0).rgb * -1; // -1_-1
    sum += source.SampleLevel(sampler_LinearClamp, uv + float2(  0, -texelSize.y ), 0).rgb * -1;  // 0_-1
    sum += source.SampleLevel(sampler_LinearClamp, uv + float2(  texelSize.x, -texelSize.y ), 0).rgb * -1; // 1_1
				
    result[dispatchThreadID.xy] = float4(saturate(sum), 1.0f);
}